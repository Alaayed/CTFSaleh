MOD = 998244353
def build_set_restrictions(restrictions, n):
    set_restrictions = [set() for _ in range(n+1)]
    for index, value in restrictions:
        set_restrictions[index-1].add(value)
    return set_restrictions
def build_shifted_restrictions(set_restrictions, n):
    # res[position][length][shift], number of valid
    res = [ [ [ False for _ in range(n+1) ] for _ in range(n+1) ] for _ in range(n+1)]
    for i in range(n): # position i
        for s in range(1, n+1-i): # length s
            for r in range(0, s): # shifted r to the left
                is_valid = True
                for c in range(0,s): # Walk the permutation
                    if (r+c) % (s) + 1 in set_restrictions[i + c]:
                        # Invalid permutations
                        is_valid = False
                        break
                res[i][s][r] = is_valid
    return res
# dp[i][j] number of ways to make
# an array of length ending with an identity permutation
# of length j
def push_dp(dp, i,j,n, lookup_table):
    if dp[i][j] == 0: #useless state
        return None
    for s in range(1, n+1-i):
        for r in range(0, s):
            # Restrictions don't allow
            if not lookup_table[i][s][r]:
                continue
            # Don't overcount, remove x+1 shifts
            if j>0 and r == j: # r is 0 indexed -> [r+1..s,1..r]
                continue
            jump = s if r == 0 else 0
            dp[i+s][jump] = (dp[i+s][jump] + dp[i][j]) % MOD

def solve():
    for _ in range(int(input())):
        n,m = map(int, input().split())
        restrictions = [list(map(int, input().split())) for _ in range(m)]
        set_restrictions = build_set_restrictions(restrictions, n)
        lookup_table = build_shifted_restrictions(set_restrictions, n)
        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]
        dp[0][0] = 1
        for i in range(0, n):
            for j in range(0, n):
                push_dp(dp, i, j,n, lookup_table)
        print(sum(dp[n]) % MOD)
solve()



# assume stars and bars
# |*|*|*|*|*
# stars are n
# each one must have AT LEAST 1 n
# one s at the start, it's fixed
# |* ? * ? *
# | *? * ?*|
# Think about some stars as pivots
# given k sections, k stars are pivots
# k-1 bars exist
# total number of positions
# k (pivots) + k-1 (bars) + n-k(normal stars)
# (n+k-1) choose (2k-1)
# Assume you have (n+k-1) empty
# positions, and what ever permutation
# is generated by the choose function
# sets the positions of pivot -> bar -> pivot...etc
# Fill in the remaining postion with stars
#
# def build_fact(n, mod= MOD):
#     fact = [1] * (n+1)
#     for i in range(1, n+1):
#         fact[i] = fact[i-1] * i % mod
#     invfact = [0] * (n+1)
#     invfact[n] = pow(fact[n], mod - 2, mod)
#
#     for i in range(n-1, -1, -1):
#         invfact[i] = invfact[i+1] * (i+1) % mod
#
#     return fact, invfact
# fact, invfact = build_fact(200)
# def choose (n,k):
#     return (fact[n] * invfact[k] * invfact[n-k]) % MOD if 0 <= k <= n else 0
